@article{Bernstein1997,
   abstract = {In this paper we study quantum computation from a complexity theoretic viewpoint. Our first result is the existence of an efficient universal quantum Turing machine in Deutsch's model of a quantum Turing machine (QTM) [Proc. Roy. Soc. London Ser. A, 400 (1985), pp. 97-117]. This construction is substantially more complicated than the corresponding construction for classical Turing machines (TMs); in fact, even simple primitives such as looping, branching, and composition are not straightforward in the context of quantum Turing machines. We establish how these familiar primitives can be implemented and introduce some new, purely quantum mechanical primitives, such as changing the computational basis and carrying out an arbitrary unitary transformation of polynomially bounded dimension. We also consider the precision to which the transition amplitudes of a quantum Turing machine need to be specified. We prove that O(log T) bits of precision suffice to support a T step computation. This justifies the claim that the quantum Turing machine model should be regarded as a discrete model of computation and not an analog one. We give the first formal evidence that quantum Turing machines violate the modern (complexity theoretic) formulation of the Church-Turing thesis. We show the existence of a problem, relative to an oracle, that can be solved in polynomial time on a quantum Turing machine, but requires superpolynomial time on a bounded-error probabilistic Turing machine, and thus not in the class BPP. The class BQP of languages that are efficiently decidable (with small error-probability) on a quantum Turing machine satisfies BPP ⊆ BQP ⊆ P P. Therefore, there is no possibility of giving a mathematical proof that quantum Turing machines are more powerful than classical probabilistic Turing machines (in the unrelativized setting) unless there is a major breakthrough in complexity theory. PII. S0097539796300921 1. Introduction. Just as the theory of computability has its foundations in the Church-Turing thesis, computational complexity theory rests upon a modern strengthening of this thesis, which asserts that any "reasonable" model of computation can be efficiently simulated on a probabilistic Turing machine (an efficient simulation is one whose running time is bounded by some polynomial in the running time of the simulated machine). Here, we take reasonable to mean in principle physically realizable. Some models of computation, though interesting for other reasons, do not meet this criterion. For example, it is clear that computers that operate on arbitrary length words in unit time or that exactly compute with infinite precision real numbers are not realizable. It has been argued that the TM (actually, the polynomial time equivalent cellular automaton model) is the inevitable choice once we assume that we can implement only finite precision computational primitives. Given the widespread belief that NP ⊆ BPP, this would seem to put a wide range of im},
   author = {Ethan Bernstein and Umesh Vazirani and Siam J Comput},
   issue = {5},
   journal = {Society for Industrial and Applied Mathematics},
   keywords = {03D10,03D15,68Q15,Fourier sampling,quantum Turing machines,quantum computation,quantum polyno-mial time,reversibility,universal quantum Turing machine AMS subject classifications 68Q05},
   pages = {7},
   title = {QUANTUM COMPLEXITY THEORY *},
   volume = {26},
   url = {http://www.siam.org/journals/sicomp/26-5/30092.html},
   year = {1997},
}
@article{Barenco1995,
   abstract = {We show that a set of gates that consists of all one-bit quantum gates [U(2)] and the two-bit exclusive-oR gate [that maps Boolean values (x,y) to (x,x&y)] is universal in the sense that all unitary operations on arbitrarily many bits n [U(2")] can be expressed as compositions of these gates. We investigate the number of the above gates required to implement other gates, such as generalized Deutsch-Toffoli gates, that apply a specific U(2) transformation to one input bit if and only if the logical AND of all remaining input bits is satisfied. These gates play a central role in many proposed constructions of quantum computational networks. We derive upper and lower bounds on the exact number of elementary gates required to build up a variety of two-and three-bit quantum gates, the asymptotic number required for n-bit Deutsch-Toffoli gates, and make some observations about the number required for arbitrary n-bit unitary operations. The state's evolution in the course of time t is described by a unitary operator U on this vector space, i.e. , a linear transformation that is bijective and length preserving. This unitary evolution on a normalized state vector is known to be the correct physical description of an isolated system evolving in time according to the laws of quantum mechanics [1]. Electronic address: a.barenco Imi ldred. physics. ox.ac.uk ~Electronic address: bennetc/divinceowatson. ibm. corn ~ Electronic address: eleve Icpsc.ucal gary. ca ~ Electronic address: nhmim. lcs.mit. edu Electronic address: shorresearch. att. corn ~ Electronic address: tycho sleator. physics. nyu. edu Electronic address: smolin vesta. physics. ucla. edu Electronic address: harald. weinfurter Iuibk. ac.at It has recently been recognized, after 50 years of using the paradigms of classical physics (as embodied in the Turing machine) to build a theory of computation, that quantum physics provides another paradigm with clearly different and possibly much more powerful features than established computation theory. In quantum computation, the state of the computer is described by a state vector 0', which is a complex linear superposition of all binary states of the bits x c (0, 1) Historically, the idea that the quantum mechanics of isolated systems should be studied as a new formal system for computation arose from the recognition 20 years ago that computation could be made reversible within the paradigm of classical physics. It is possible to perform any computation in a way that is reversible both logically, i.e. , the computation is a sequence of bijective transformations, and ther-mody nami cally, i.e. , the computation could in principle be performed by a physical apparatus dissipating arbitrarily little energy [2].A formalism for constructing reversible Tur-ing machines and reversible gate arrays (i.e., reversible com-binational logic) was developed. Fredkin and Toffoli [3] showed that there exists a three-bit "universal gate" for reversible computation, that is, a gate that, when applied in succession to different triplets of bits in a gate array, could be used to simulate any arbitrary reversible computation. (Two-bit gates such as NAND that are universal for ordinary computation are not reversible.) Toffoli's version [4] of the universal reversible gate will figure prominently in the body of this paper. Quantum physics is also reversible because the reverse-time evolution specified by the unitary operator U '= U~ always exists; as a consequence, several workers recognized that reversible computation could be executed within a quantum-mechanical system. Quantum-mechanical Turing machines [5,6], gate arrays [7], and cellular automata [8] have been discussed and physical realizations of Toffoli's [9-11] and Fredkin*s [12-14] universal three-bit gates within various quantum-mechanical physical systems have been proposed.},
   author = {Adriano Barenco and Charles H Bennett and Richard Cleve and David P DiVincenzo and Norman Margolus and Peter Shor and Tycho Sleator and John A Smolin and Harald Weinfurter and I Background},
   issue = {5},
   journal = {PHYSICAL REVIEW A},
   keywords = {0270Rw,0705Bx,8980+h,number(s): 0365Ca},
   title = {Elementary gates for quantum computation NOVEMBER 1995},
   volume = {52},
   year = {1995},
}
@article{Heim2020,
   abstract = {Quantum programming languages are essential to translate ideas into instructions that can be executed by a quantum computer. Not only are they crucial to the programming of quantum computers at scale but also they can facilitate the discovery and development of quantum algorithms even before hardware exists that is capable of executing them. Quantum programming languages are used for controlling existing physical devices, for estimating the execution costs of quantum algorithms on future devices, for teaching quantum computing concepts, or for verifying quantum algorithms and their implementations. They are used by newcomers and seasoned practitioners, researchers and developers working on the next ground-breaking discovery or applying known concepts to real-world problems. This variety in purpose and target audiences is reflected in the design and ecosystem of the existing quantum programming languages, depending on which factors a language prioritizes. In this Review, we highlight important aspects of quantum programming and how it differs from conventional programming. We overview a selection of several state-of-the-art quantum programming languages, highlight their salient features, and provide code samples for each of the languages and Docker files to facilitate installation of the software packages.},
   author = {Bettina Heim and Mathias Soeken and Sarah Marshall and Chris Granade and Martin Roetteler and Alan Geller and Matthias Troyer and Krysta Svore},
   doi = {10.1038/s42254-020-00245-7},
   issn = {25225820},
   issue = {12},
   journal = {Nature Reviews Physics},
   month = {12},
   pages = {709-722},
   publisher = {Springer Nature},
   title = {Quantum programming languages},
   volume = {2},
   year = {2020},
}
@web_page{,
   title = {Qiskit Official Documentation},
   url = {https://qiskit.org/documentation/},
}
