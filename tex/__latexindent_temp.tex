\documentclass[a4paper,11pt,oneside,openany]{iut-thesis}
\input{./settings}
\usepackage{braket}
\usepackage{bbold}
\usepackage{hyperref}
\begin{document}
	
%%===============================TITLE===============================%%

\university{
	دانشگاه صنعتی اصفهان
}
\department{
	دانشکده فیزیک
}
\type{
	گزارش پروژه
}
\degree{
	درس
}
\subject{
	مکانیک کوانتومی ۲
}
\field{
}
\title{
مقدمه‌ای بر برنامه‌نویسی کوانتومی با کیت توسعه نرم‌افزار  Qiskit
}
\tit{}
\supervisor{
	دکتر مهدی عبدی
}
\secsupervisor{
}
\advisor{
}
\secadvisor{} 
\author{
	محمدحسین سلیمی}
\thesisdate{بهار ۱۴۰۰}

\makefatitle

%%===============================TITLE===============================%%
%%===============================ABSTRACT===============================%%

\begin{abstract}
زبان‌های برنامه‌نویسی کوانتومی ابزاری هستند که با استفاده از آن‌ها می‌توان ایده‌های مختلف را به سری دستوراتی تبدیل کرد که کامپیوترهای کوانتومی قادر به اجرای آن‌ها باشند. نه تنها آن‌ها برای کار با کامپیوترهای کوانتومی نیاز هستند، بلکه باعث کشف و توسعه الگوریتم‌های کوانتومی، حتی پیش از به وجود آمدن سخت‌افزار با قابلیت اجرای آن‌ها، نیز شده‌اند. از این زبان‌ها برای کنترل دستگاه‌های موجود، ارزیابی بازدهی الگوریتم‌های مختلف بر روی دستگاه‌های در دست تولید،‌ کالیبرازیسیون دستگاه‌ها، آموزش مفاهیم محاسبات کوانتومی و ساخت انواع مختلف الگوریتم‌های کوانتومی استفاده می‌شود. 
در این گزارش قصد دارم تا با معرفی یکی از چارچوب‌های برنامه‌نویسی کوانتومی، Qiskit ، با مفاهیم کلی برنامه‌نویسی کوانتومی آشنا شویم، الگوریتم کوانتومی‌ای را پیاده سازی و کد آن را اجرا کنیم.
\end{abstract}
\newpage

\tableofcontents

\newpage
%%===============================ABSTRACT===============================%%

%%===============================SECTION-1===============================%%

\section{
مقدمه
}
در سال ۲۰۱۷ شرکت IBM برای اولین بار یک کیت توسعه نرم‌افزارِ(SDK) متن باز(open-source) برای محاسبات کوانتومی به نام Qiskit را معرفی کرد. Qiskit ابزارهایی برای خلق و دست‌کاری برنامه‌های کوانتومی در اختیار کاربر قرار می‌دهد و این اجازه را می‌دهد تا کاربر بر روی یک کامپیوتر کوانتومی شبیه‌سازی شده بر روی سیستم خودش، کارایی کدش را بررسی کند.

 نسخه اصلی این کیت از زبان برنامه‌نویسی پایتون استفاده می‌کند که کار را برای کاربران کمی ساده‌‌تر می‌کند. چرا که در حالت کلی برای اجرای دستوراتی بر روی کامپیوترها باید از زبان‌های سطح پایین، مانند Assembly ، استفاده کرد. کامپیوترهای کوانتومی نیز از این قاعده مستثنی نیستند. Qiskit این قابلیت را فراهم می‌آورد تا با استفاده از یک زبان سطح بالا، پایتون، کاربر دستورات خود را به ماشن بفهماند.( منظور    از زبان سطح بالا زبانی است که از زبان ماشین دورتر است و کاربران راحت‌تر با آن‌ها کار می‌کنند.) البته نسخه میکرویی از این کیت وجود دارد که از زبان‌های جاوااسکریپت و سوئیفت نیز پشتیبانی می‌کند.

یکی از بزرگترین مزیت‌های استفاده از این کیت،‌ داشتن دسترسی به کامپیوترهای کوانتومی  شرکت IBM است. این شرکت یک پلتفرم آنلاین به اسم تجربه‌ی کوانتومی آی‌بی‌ام (IBM-Q-Experience) به وجود آورده است که به کاربران این اجازه را می‌دهد تا برنامه‌های کوانتومی نوشته شده خود با Qiskit را بر روی کامپیوتر‌های کوانتومی واقعی اجرا کنند. در نسخه رایگان این پلتفرم، کاربران به ۱۴ کامپیوتر کوانتومی که حداکثر تا ۱۵ کیوبیت دارند،‌دسترسی دارند.


%%===============================SECTION-1===============================%%
%%===============================SECTION-2===============================%%
\section{
گیت کوانتومی
}
\subsection{
گیت‌های پاولی
}
در پایین‌ترین سطح، الگوریتم‌های کوانتومی از یک سری پایه‌ها و یا بنیادها ساخته شده‌اند. درست مانند اگوریتم‌های کلاسیکی که در پایین‌ترین سطح از گیت‌های AND ، NOT و OR  ساخته شده‌اند. در این بخش قصد داریم تا کمی با این پایه‌ها آشنا شویم. 

یک سیستم کوانتومی ایده‌آل از $n$ کیوبیت که با حالت مختلط $C^{2^n}$ تعریف می‌شود، تشکیل می‌شود. برای مثال،‌ حالت یک سیستم تک کیوبیتی را می‌توان به صورت
\begin{equation}
\ket \psi = \alpha \ket 0 + \beta \ket 1
\end{equation}
نوشت. که در آن $\alpha $ و $\beta $ اعدادی مختلط و $ \ket 0 =\bigl( \begin{smallmatrix} 1 \\ 0 \end{smallmatrix}\bigr) $ و  $ \ket 1 =\bigl( \begin{smallmatrix} 0 \\ 1 \end{smallmatrix}\bigr) $ هستند.

انجام محاسبات در الگوریتم‌های کوانتومی در اصل انجام یک سری تحولات ریاضی بر روی بردار حالت است. این تحولات به واسطه ماتریس‌های یکانی مختلط  $ 2^n \times 2^n $ صورت میگیرد که به آن‌ها گیت‌های کوانتومی گفته می‌شود.

 حالت یک کیوبیت از $ \ket 0 $ به $ \ket 1 $ زمانی تغییر میکند که گیت کوانتومی یا عملگر $ X $ بر روی آن اثر کند که به صورت زیر تعریف می‌شود:
\begin{equation}
X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} .
\end{equation}
تحولات اعمالی بر روی یک کیوبیت از یک سیستم چند کیوبیتی را می‌توان با ضرب تانسوری $ X $  و ماتریس همانی، $ \mathbb{1} $، بدست آورد. به طور مثال،‌ تاثیر اعمال $ X $  بر روی دومین کیوبیت از یک سیستم سه کیوبیتی به صورت $ \mathbb{1} \otimes X \otimes \mathbb{1} $  خواهد بود.
عملگر $X$ یکی از سه عملگر پاولی است که به همراه ماتریس همانی، پایه‌ی تمام تحولات یکانی بر روی تک کیوبیت را تشکیل می‌دهند. نمایش ماتریسی دو عملگر دیگر $Y$ و $Z$ به صورت زیر است:
\begin{equation}
Y = \begin{pmatrix} 0 & -i \\ -i & 0 \end{pmatrix}, \;
Z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}.
\end{equation}
\subsection{
گیت آدامار
}
این عملگر که بر روی یک کیوبیت عمل میکند، حالت پایه $ \ket 0 $ را به حالت  $ \frac{\ket 0 + \ket 1 }{\sqrt{2}} $ و حالت پایه $ \ket 1 $ را به حالت $ \frac{\ket 0 - \ket 1 }{\sqrt{2}} $ می‌برد. در نتیجه اعمال این عملگر روی یک حالت پایه، برهم‌نهی کوانتومی به وجود می‌آورد که در صورت اندازه‌گیری، با احتمالی برابر، می‌تواند $\ket 0 $ و یا $ \ket 1 $ شود. نمایش ماتریسی آن به صورت زیر است:
\begin{equation}
H = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}.
\end{equation}

\subsection{
گیت CX
}
این گیت بر روی دو کیوبیت اثر می‌کند. بدین صورت که یکی از کیوبیت‌ها را به عنوان کنترل و دیگری را به عنوان هدف در نظر میگیرد. در صورتی که کیوبیت کنترل در حالت $ \ket 1 $ باشد،‌این گیت عملگر $ X $ را بر روی کیوبیت هدف اثر می‌دهد. اگر کیوبیت کنترل در حالت برهم‌نهی ( superposition ) باشد، آنگاه این گیت باعث به وجود آمدن درهم تنیدگی بین دو کیوبیت می‌شود. در بعضی مراجع به این گیت CNOT و یا controlled-NOT نیز می‌گویند. نمایش ماتریسی آن به صورت زیر است:
\begin{equation}
CX =  \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0&0&0&1 \\ 0&0&1&0 \end{pmatrix}.
\end{equation}







%%===============================SECTION-2===============================%%
%%===============================SECTION-3===============================%%
\section{
سلام دنیا!!!
}
یکی از سنت‌های یادگیری زبانی جدید در بین برنامه‌نویسان، نوشتن برنامه‌ای به نام hello-world است. بدین صورت که برنامه‌ای خیلی ساده و گاها تک خطی نوشته می‌شود که فقط یک جمله، hello-world ، را چاپ می‌کند. هدف از انجام این کار، بررسی نصب صحیح اجزای زبان بر روی سیستم و یادگیری اجرای برنامه‌ها در زبان جدید است. در این بخش قصد داریم تا با پیروی از این سنت، یک hello-world کوانتومی با استفاده از Qiskit بنویسیم و آن را اجرا کنیم.

در این برنامه کوچک یک مدار کوانتومی دو کیبویتی تشکیل می‌دهیم، درهم تنیدگی به وجود می‌آوریم و احتمال را محاسبه می‌کنیم.
\subsection{
نصب
}
پیش از هر کاری باید Qiskit را نصب کنیم. همانطور که گفته شد، این کیت بر روی پایتون سوار است و از امکانات این زبان استفاده می‌کند، پس باید پایتون بر روی سیستم وجود داشته باشد. اگر از سیستم‌های یونیکسی( گنو/لینوکس، مک) استفاده می‌کنید، پایتون به صورت پیش فرض روی سیستم‌تان وجود دارد. اگر کاربر ویندوز هستید، می‌توانید به مراجعه به سایت رسمی پایتون به نشانی \url{www.python.org}، اقدام به نصب آن کنید.

این کیت به صورتی کتابخانه‌ای قابل نصب بر روی پکیج منیجر پایتون، pip، وجود دارد. پیشنهاد می‌شود که قبل از نصب Qiskit ، ابتدا یک محیط مجازی پایتون( \href{ https://pypi.org/project/virtualenv/}{virtualenv}) بر روی سیستم خود به وجود آورید و پس از فعال کردن آن اقدام به نصب Qiskit کنید. برای نصب Qiskit از دستور ساده زیر در محیط ترمینال می‌توانید استفاده کنید. 


\begin{latin}
\begin{lstlisting}[style=Mybash]
pip install qiskit
pip install matplotlib
\end{lstlisting}
\end{latin}
پکیج matplotlib برای نمایش نمودارها لازم است.
\subsection{
ساخت مدار
}
با فراخوانی پکیج‌های مورد نیاز شروع می‌کنیم
\begin{latin}
\begin{lstlisting}[style=Mypython]
from qiskit import * 
import matplotlib
from qiskit.visualization import plot_histogram
from qiskit.tools.monitor import job_monitor
\end{lstlisting}
\end{latin}
سپس باید یک مدار کوانتومی با دو کیوبیت و دو بیت کلاسیکی تشکیل دهیم. بیت‌های کلاسیکی برای ذخیره نتایج مشاهده شده استفاده می‌شوند.
\begin{latin}
\begin{lstlisting}[style=Mypython]
circuit = QuantumCircuit(2,2)
\end{lstlisting}
\end{latin}
با استفاده از دستور 
\begin{latin}
\begin{lstlisting}[style=Mypython]
circuit.draw(output='mpl')
\end{lstlisting}
\end{latin}
می‌توان تصویر مدار ساخته شده را دید که به صورت زیر خواهد بود.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{cirdraw}
	\caption{
	مدار کوانتومی شامل دو کیوبیت و دو بیت کلاسیکی 
	}
	\label{cirdraw}
\end{figure} 


اکنون به مدار ساخته شده گیت‌ها را اضافه می‌کنیم. دو کیوبیت تشکیل شده در مدار داری اندیس‌های صفر و یک هستند که به ترتین کیوبیت اول و دوم را مشخص می‌کنند.

گیت آدامار را بر روی کیوبیت با اندیس صفر اضافه می‌کنیم. سپس گیت CX را اعمال میکنیم. ترتیب به این صورت است که عدد اول، اندیس کیوبیت کنترل و عدد دوم اندیس کیوبیت هدف است. سپس اندازه‌گیری بر روی کیوبیت‌های صفر و یک انجام  می‌شود و نتایج در بیت‌های کلاسیکی صفر و یک دخیره می‌شود.


\begin{latin}
\begin{lstlisting}[style=Mypython]
circuit.h(0)
circuit.cx(0,1)
circuit.measure([0,1], [0,1])
circuit.draw(output='mpl')
\end{lstlisting}
\end{latin}
و در آخر دوباره تصویر مدار ساخته می‌شود.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{cir2}
	\caption{
	مدار کوانتومی نهایی 
	}
	\label{cir2}
\end{figure} 

\newpage


\subsection{
اجرا بر روی شبیه‌ساز
}

از مزیت‌های خوب Qiskit ، همراه شدن آن با شبیه‌سازهای موضعی (local) است. به این منظور که کاربران بر روی سیستم خود می‌توانند یک کامپیوتر کوانتومی تقریبا ایده‌آل داشته باشند. در اینجا قصد داریم تا با استفاده از qasm-simulator که یک موتور شبیه‌سازی است که همراه Qiskit بر روی سیسنم کاربر نصب می‌شود، کد نوشته شده خود را اجرا کنیم.

ابتدا موتور شبیه‌ساز را تعریف می‌کنیم
\begin{latin}
\begin{lstlisting}[style=Mypython]
simulator = Aer.get_backend('qasm_simulator')
\end{lstlisting}
\end{latin}

سپس مدار را بر روی این شبیه‌ساز اجرا می‌کنیم و نتایج به دست آمده را در متغیر$result$  ذخیره می‌کنیم. در آخر نمودار نتایج به دست آمده از شبیه‌سازی را رسم می‌کنیم.

\begin{latin}
\begin{lstlisting}[style=Mypython]
result = execute(circuit, backend=simulator).result()
plot_histogram(result.get_counts(circuit))
\end{lstlisting}
\end{latin}
در آخر نمودار نتایج به دست آمده از شبیه‌سازی را رسم می‌کنیم.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{plot}
	\caption{
	نمودار احتمال
	}
	\label{plot}
\end{figure} 

\subsection{
اجرا بر روی کامپیوتر کوانتومی واقعی
}
اکنون می‌خواهیم برنامه خود را بر روی یک کامپیوتر کوانتومی واقعی اجرا کنیم و نتیجه آن را با نتیجه قسمت قبل مقایسه کنیم.

 برای این کار ابتدا با مراجعه به سایت  \url{quantum-computing.ibm.com} یک حساب کاربری ایجاد می‌کنیم. با مراجعه به قسمت پروفایل حساب کاربری، API-token را کپی کرده و با استفاده از دستور پایتونی زیر سیستم خود را به حساب کاربری IBM متصل می‌کنیم.
\begin{latin}
\begin{lstlisting}[style=Mypython]
IBMQ.save_account('<API token>')
\end{lstlisting}
\end{latin}

اکنون می‌توانیم حساب کاربری خود را درون کد فراخوانی کنیم و با استفاده از آن به کامپیوترها کوانتومی شرکت IBM متصل شویم. سپس نوع کامپیوتری که میخواهیم به آن متصل شویم را مشخص می‌کنیم و در مرحله بعد نام کامپیوتر را تعریف می‌کنیم. در اینجا ibmq-16-melbourne  نام کامپیتر مورد استفاده است. 
\begin{latin}
\begin{lstlisting}[style=Mypython]
IBMQ.load_account()
provider = IBMQ.get_provider(hub = 'ibm-q')
qcomp = provider.get_backend('ibmq_16_melbourne')
\end{lstlisting}
\end{latin}

اکنون مدار را بر روی کامپیوتر مورد نظر اجرا می‌کنیم.  
\begin{latin}
\begin{lstlisting}[style=Mypython]
job = execute(circuit, backend=qcomp)
\end{lstlisting}
\end{latin}
با توجه به این که این کامپیوترها در اختیار عموم قرار دارند، ممکن است مدتی در صف منتظر بمانیم تا کد اجرا شود. با دستور زیر می‌توانیم از وضعیت job مطلع شویم. این دستور به صورت اتوانیک خود را آپدیت میکند.

\begin{latin}
\begin{lstlisting}[style=Mypython]
job_monitor(job)
\end{lstlisting}
\end{latin}

پس از انجام job ، نتیحه به دست آمده را در متغیر $result$ ذخیره می‌کنیم و نمودار احنمال را رسم می‌کنیم.
\begin{latin}
\begin{lstlisting}[style=Mypython]
result = job.result()
plot_histogram(result.get_counts(circuit))
\end{lstlisting}
\end{latin}

نمودار نهایی به صورت زیر است که همانگونه که مشاهده میکنید با قسمت قبل متفاوت است. دلیل این تفاوت نیز این است که کامپیوترهای کوانتومی واقعی درصدی خطا دارند که ممکن است در اثر نویزهای سیستمی، کالیبره نبودن دستگاه و یا دلایلی دیگر باشد.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{final}
	\caption{
	نمودار احتمال بدست آمده از کامپیوتر کوانتومی واقعی
	}
	\label{final}
\end{figure}
\newpage


\subsection{
یک تکه کد
}
از آنجایی که ممکن است صف‌های طولانی‌ای برای استفاده از دستگاه‌ها شکل بگیرد،‌ می‌توان با اجرا کردن تکه کد زیر خلوت‌ترین کامپیوتر کوانتومی را پیدا کرد و از آن استفاده کرد.

با تغییر مقدار متغییر $num_qubits$ می‌توان حد پایین تعداد کیوبیت‌های دستگاه را مشخص کرد.
\begin{latin}
\begin{lstlisting}[style=Mypython]
num_qubits = 2

from qiskit.providers.ibmq import least_busy
possible_devices = provider.backends(filters=lambda x: 
                                     x.configuration().n_qubits >= num_qubits
                                       and 
                                     x.configuration().simulator == False)
qcomp = least_busy(possible_devices)
print(qcomp)
\end{lstlisting}
\end{latin}

%%===============================SECTION-3===============================%%
%%===============================SECTION-4===============================%%
\section{
مثالی دیگر
}
به عنوان مثالی دیگر، در این بخش به معرفی الگوریتم برنستین-وزیرانی می‌پردازیم و آن را در Qiskit پیاده سازی می‌کنیم.
\subsection{
الگوریتم برنستین-وزیرانی
}

فرض کنیم یک جعبه سیاه حاوی یک رشته کاراکتر داریم که میخواهیم آن را حدس بزنیم. کاراکترهای این رشته فقط می‌توانند ۱ و یا ۰ باشند. خاصیت این جعبه آن است که رشته کاراکتر دریافتی از ما را با رشته کاراکتر درون خودش بیت به بیت مقایسه می‌کند. یعنی اگر رشته دارای سه کاراکتر باشد، به ترتیب از راست به چپ کاراکترها را تک به تک باهم مقایسه میکند و اگر دو کاراکتر ۱ بودند، ۱ برمیگرداند و در غیر این صورت ۰ باز گردانده می‌شود.

یک کامپیوتر کلاسیکی، پس از $n$  بار حدس، می‌تواند یک رشته کاراکتر $n$ تایی را حدس بزند. به عنوان مثال، فرض کنید که رشته درون جعبه $110$ است. حدس اول کامپیوتر کلاسیکی اگر $001$ باشد،  مشخص میشود که کاراکتر اول از سمت راست رشته درون جعبه صفر است. اگر حدس بعدی آن $010$ باشد، مشخص می‌شود که کاراکتر دوم، یک است. به همین ترتیب آخرین کاراکتر نیز معلوم می‌شود و رشته حدس زده می‌شود.

همین مسئله را یک کامپیوتر کوانتومی با استفاده از الگوریتم برنستین-وزیرانی میتواند در یک حدس حل کند. 
در حالت کلی، فرم ریاضی این الگوریتم به صورت زیر است:
\begin{equation}
|00\dots 0\rangle \xrightarrow{H^{\otimes n}} \frac{1}{\sqrt{2^n}} \sum_{x\in \{0,1\}^n} |x\rangle \xrightarrow{f_s} \frac{1}{\sqrt{2^n}} \sum_{x\in \{0,1\}^n} (-1)^{s\cdot x}|x\rangle \xrightarrow{H^{\otimes n}} |s\rangle .
\end{equation}

که در آن $f_s$ جعبه حاوی رشته کاراکتر $s$ است. به عنوان مثال فرض کنید $n=2$  کیوبیت داریم و رشته درون جعبه $s=11$  است. کیوبیت‌ها در حالت اولیه $ \ket \psi_{0} = \ket{00} $ قرار دارند. با اعمال گیت آدامار بر روی دو کیوبیت خواهیم داشت:
\begin{equation}
\lvert \psi_1 \rangle = \frac{1}{2} \left( \lvert 0 0 \rangle + \lvert 0 1 \rangle + \lvert 1 0 \rangle + \lvert 1 1 \rangle \right) 
\end{equation}


اکنون باید تاثیر جعبه بر روی کیوبیت‌ها را اعمال کنیم. که برای $s=11$ به صورت زیر خواهد بود:
\begin{equation}
|x \rangle \xrightarrow{f_s} (-1)^{x\cdot 11} |x \rangle.
\end{equation}
 پس 
\begin{equation}
\lvert \psi_2 \rangle = \frac{1}{2} \left( (-1)^{00\cdot 11}|00\rangle + (-1)^{01\cdot 11}|01\rangle + (-1)^{10\cdot 11}|10\rangle + (-1)^{11\cdot 11}|11\rangle \right)
\end{equation}
که پس از ساده سازی خواهیم داشت:
\begin{equation}
\lvert \psi_2 \rangle = \frac{1}{2} \left( \lvert 0 0 \rangle - \lvert 0 1 \rangle - \lvert 1 0 \rangle + \lvert 1 1 \rangle \right)
\end{equation}
با اعمال دوباره گیت آدامار خواهیم داشت:
\begin{equation}
\lvert \psi_3 \rangle = \lvert 1 1 \rangle
\end{equation}

که با اندازه گیری به $s=11$ خواهیم رسید.
\subsection{
پیاده سازی در Qiskit
}
مانند برنامه‌ی سلام دنیا، با فراخوانی پکیج‌های مورد نیاز آغاز می‌کنیم
\begin{latin}
\begin{lstlisting}[style=Mypython]
from qiskit import * 
import matplotlib
from qiskit.visualization import plot_histogram
from qiskit.tools.monitor import job_monitor
\end{lstlisting}
\end{latin}

رشته $s$ را تعریف می‌کنیم و بر اساس آن مدار را می‌سازیم
\begin{latin}
\begin{lstlisting}[style=Mypython]
s = '1101'
n = len(s)
circuit = QuantumCircuit(n+1,n)
\end{lstlisting}
\end{latin}
تعداد کیوبیت‌ها را یکی بیشتر از تعداد کاراکترهای رشته در نظر می‌گیریم. در Qiskit کیوبیت‌ها دارای حالت اولیه $\ket 0$ هستند، پس فقط بر روی کیوبیت آخر عملگر $X$ را اعمال می‌کنیم. از کیوبیت آخر برای به وجود آوردن جعبه استفاده می‌کنیم. بر روی تمام کیوبیت‌ها گیت آدامار را اثر میدهیم. سپس جعبه را می سازیم. بدین صورت که عملگر $CX$ را بر روی کیوبیت‌هایی که شامل کاراکتر ۱ هستند و کیوبیت آخر اثر می‌دهیم. این که را در جهت معکوس انجام می‌دهیم. بدین صورت که اگر اولین کاراکتر رشته ۱ بود، یک عملگر $CX$ بر روی $n$ امین کیوبیت و کیوبیت آخر اعمال می‌کنیم. سپس دوباره بر روی تمامی کیوبیت‌ها گیت آدامار را اثر می‌دهیم و احتمال را اندازه‌گیری می‌کنیم
\begin{latin}
\begin{lstlisting}[style=Mypython]
circuit.x(n)
circuit.barrier()
circuit.h(range(n+1))
circuit.barrier()
for ii, yesno in enumerate(reversed(s)):
    if yesno == '1':
        circuit.cx(ii,n)

circuit.barrier()
circuit.h(range(n+1))
circuit.measure(range(n), range(n))
\end{lstlisting}
\end{latin}
با استفاده از دستور

\begin{latin}
\begin{lstlisting}[style=Mypython]
circuit.draw(output='mpl')
\end{lstlisting}
\end{latin}
مدار را جهت مشاهده رسم می‌کنیم که به صورت زیر در می‌آید.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{bv}
	\caption{
	مدار کوانتومی الگوریتم برنستین-وزیرانی
	}
	\label{bv}
\end{figure}
خطوط عمودی‌ای که بر روی مدار وجود دارند صرفا به منظور تفکیک قسمت‌های مختلف مدار به هنگام مشاهده شکل مدار است.

همانند قسمت قبل، برای اجرای مدار یک بار از شبیه ساز موضعی و یک بار از کامپیوتر کوانتومی واقعی استفاده خواهیم کرد.

\subsection{
اجرا بر روی شبیه‌ساز
}
تعداد دفعات انجم آزمایش را برابر یک می‌گذاریم تا بیشتر انجام نشود.
\begin{latin}
\begin{lstlisting}[style=Mypython]
simulator = Aer.get_backend('qasm_simulator')
result = execute(circuit, backend=simulator, shots=1).result()
plot_histogram(result.get_counts(circuit))
\end{lstlisting}
\end{latin}

نتیجه به دست آمده به صورت زیر است. در یک بار آزمایش، نتیجه به دست آمده $1101$ است که برابر است با رشته‌ای که از اول تعریف کرده بودیم.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{bvp1}
	\caption{
	نتیجه شبیه سازی موضعی
	}
	\label{bvp1}
\end{figure}
\subsection{
اجرا بر روی کامپیوتر کوانتومی واقعی
}
مانند قسمت قبل کد را بر روی کامپیوتر کوانتومی واقعی اجرا می‌کنیم
\begin{latin}
\begin{lstlisting}[style=Mypython]
IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q')
qcomp = provider.get_backend('ibmq_16_melbourne')
job = execute(circuit,backend=qcomp)
job_monitor(job)
resualt = job.result()
plot_histogram(resualt.get_counts(circuit))
\end{lstlisting}
\end{latin}
که نتیجه آن به صورت زیر است.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{bvp2}
	\caption{
	نتیجه بدست آمده از کامپیوتر کوانتومی واقعی
	}
	\label{bvp2}
\end{figure}
همانطور که مشخص است با یک بار انجام آزمایش، با احتمال نزدیک به ۷۰ درصد رشته کاراکتر درست را بدست آورده است.
%%===============================SECTION-4===============================%%

%%===============================SECTION-5===============================%%
\section{
سخن پایانی
}

چارچوب‌ها و کیت‌های توسعه نرم‌افزار و حتی زبان‌های گوناگونی برای برنامه‌نویسی کوانتومی وجود دارند و Qiskit فقط یکی از آن‌هاست. هر کدام از این تکنولوژی‌ها قابلیت‌ها، مزایا و معایب خود را دارند. اما  همه‌شان یک وجه مشترک‌ دارند، و آن هم ارزش حداقل یک‌بار استفاده از آن‌هاست. استفاده از این تکنولوژی‌ها به درک بسیاری از مطالب کوانتومی و علوم کامپیوتر کمک می‌کند و باعث می‌شود بیشتر به دنبال یادگیری باشیم.  کامپیوترهای کوانتومی روز به روز پیشرفته‌تر می‌شوند و کار با آن‌ها راحت‌تر می‌شود. گسترش و یادگیری این تکنولوژی‌ها به پیشرفت این نوع کامپیوترها نیز کمک بسیاری می‌کنند. 

تمامی کدهای توضیح داده شده در این گزارش به همراه jupyter-notebook های آن‌ها در یک مخرن گیت‌هاب به آدرس \url{github.com/Perun21/q2-qiskit} قابل دسترسی می‌باشند و می‌توانید از آن‌ها استفاده نمایید.

%%===============================SECTION-5===============================%%
%%===============================BIBLIOGRAPHY===============================%%

%%===============================BIBLIOGRAPHY===============================%%

%{\bibliographystyle{iut-fa.bst}
{\bibliographystyle{ieeetr-fa.bst}
%{\bibliographystyle{plainurl}
%{\bibliographystyle{plain-fa.bst}
% \setLTRbibitems
% \resetlatinfont

\DefaultMathsDigits
\begin{singlespace}
\nocite{*}
\bibliography{lib}
\end{singlespace}
%\nocite{*}
%\bibliographystyle{amsplain}
%\bibliography{library}
%\end{document}

%%===============================BIBLIOGRAPHY===============================%%
%%===============================BIBLIOGRAPHY===============================%%
\end{document}
